## 컴퓨터가 뺄셈 하는 방법
- 6에 4를 더하면 10이다. 즉, 4는 6에 대한 10의 보수이다
- 보수 더하기하면 자동으로 뺄셈이됨
- 2진수에서 0은 1로, 1은 0으로 뒤집으면 1의 보수가 된다.
- 2의 보수를 더하면 자동으로 2진수 뺄셈이 된다, 단 자리올림은 버린다.
- 위의 모든 것은 정수에 관한 이야기
- IEEE 754 표준은 실수에 관한 이야기

## CPU가 곱하고 나누는 방법
  ### 곱하기
  - 4비트로 5를 표현하면 0101이다.
  - 4비트를 0101을 왼쪽으로 한칸씩 밀면(Shift)1010이다.
  - 맨 오른쪽에 0(Padding)이 채워진다.
  - 4비트로 표현하는 2진수 1010은 10이다.
  - 왼쪽으로 한 칸 밀면 곱하기2, 두칸 밀면 곱하기 4가 된다.
  ### 나누기
  - 4비트로 6을 표현하면 0110이다.
  - 4비트 0110을 오른쪽으로 한 칸씩 밀면 0011이다.
  - 맨 오른쪽에 0이 채워진다.(padding)
  - 4비트로 표현하는 2진수 0011은 3이다.
  - 뺄셈으로 할때는 나누려는 수를 나눌 수로 빼기해서 음의 수가 나올 까지 실행된 횟수가 값이다.
  - 7을 0으로 나누면?
  - 만날 수 없다면 뺄셈 연산은 끝나지않기 때문에 무한으로 실행되어 무한루프에 빠짐
  - 절대적으로 0으로 나누면 안됨 무조건 오류 발생시킴!

## 컴퓨터가 연산하는 방법
- RAM 일련 번호가 있고 거기에 저장함 
- 메모리는 Excel과 비슷하다.
- CPU는 RAM에서 가져온 정보를 Register로 가져옴 
- ALU 산수하는것 
- 그 결과를 메모리로 다시 보내줌
- 4,294,967,296 = 2 <sup>32</sup>  관리가능한 최대 크기(32비트에서 4GB까지 인식가능)
- 1차 메모리 RAM 2차 메모리 SSD나 HDD

## 기억공간을 관리하는 방법
- CPU하고 RAM 사이에 속도차가 남
- 2차 메모리하고CPU 하고 속도 차이는 어마어마하게 남
- 그래서 그 차이를 극복하고자 RAM이 중간사이에 있음 
- CPU RAM은 휘발성 메모리임 
- 캐시 메모리 정보 - 코드, 연산대상이 있음
- CPU가 속도차이가 나므로 미리 예측해서 미리 캐시 메모리에 저장 
- 기본저긍로 모든 것이 다 숫자이다.
- 정보가 저장된 위치도 숫자로 표시한다.
- 레지스터, 주 기억장치(RAM),보조 기억장치(HDD,SSD)를 관리하는 방식은 조금씩 다르다.
  - 레지스터는 개별 기억공간마다 고유 이름을 붙인다.
  - 주 기억장치는 일련번호를 붙인다.
  - 보조기억장치는 트렉(Track)번호와 섹터(Sector)번호를 붙여 관리한다.(파일(File)의 등장)
 
## HDD,SSD와 파일 시스템
- 주 기억장치 공간은 일련번호로 관리한다.
- 하드디스크에 자성 정보를 저장하게 되있음 
- 하드는 디스크 회전속도를 논함 속도가 빠를수록 읽기 쓰기 속도가 빠름
- 하드디스크는 트랙과 섹터로 이루어져있다.
- 섹터에서 읽기 쓰기하는데 OS가 빈공간을 찾아 넣어줌 
- 읽기 쓰기가 안되는 섹터를 배드섹터라 한다.
- 보통 섹터 하나가 512바이트로 잡는다.
- 오버라이트 많이 하면 망가진다.
- 조각모음 : 입출력 성능을 좋게 하기 위해 사용
- 파일 시스템 : NTFS(윈도우) 파일을 어디에 저장했는지 테이블(File Alocation Table) 형태로 트랙과 섹터와 파일명 등등으로 표현함
- 파일을 지우면 첫글자나 둘째 글자에 #으로 표시하고 Delete 테이블에 표시를 한다. 트랙과 섹터에서 지우지않음
- 0번트랙 0번섹터는 마스터부트레코드(특별함) OS의 부트로더가 들어감 
- Format : 테이블을 싹 다 초기화 시키는 것 빠른 포멧은 메타데이터만 날리는 것  